# ZK-Email Verification System - Design Document

## Overview

The ZK-Email verification system enables privacy-preserving civic engagement by allowing users to prove they contacted government representatives without revealing email content. The system integrates the ZK-Email SDK for zero-knowledge proof generation and connects to NEAR blockchain for reward distribution.

## Architecture

### Frontend (Next.js + React)
- **ProofOfAction Component**: Main UI for civic engagement campaigns
- **Email Upload**: File input for .eml email files with drag-and-drop support
- **Campaign Selection**: UI for choosing civic engagement campaigns (Chat Control, Sugar Tax, Sleep Compensation)
- **ZK-Email SDK Integration**: Client-side proof generation using @zk-email/sdk
- **Progress Tracking**: Visual feedback during proof generation and verification

### Backend (Python FastAPI)
- **Email Processing**: Parse .eml files and extract headers/metadata
- **DKIM Validation**: Verify email authenticity using cryptographic signatures
- **Representative Database**: Validate recipient addresses against government contact lists
- **Proof Verification**: Validate ZK proofs generated by frontend
- **NEAR Integration**: Reward distribution via smart contracts

### ZK-Email Integration
- **Blueprint Registry**: Use existing blueprints or create custom ones for civic engagement
- **Proof Generation**: Client-side ZK proof creation from email content
- **On-Chain Verification**: Verify proofs on NEAR blockchain for reward distribution
- **Off-Chain Verification**: Fast validation for immediate user feedback

## Components and Interfaces

### ZK-Email SDK Integration
```typescript
import zkeSDK, { Proof } from "@zk-email/sdk";

class CivicEngagementProver {
    private sdk = zkeSDK();
    
    async generateCivicProof(emlContent: string, campaign: Campaign): Promise<Proof> {
        const blueprint = await this.sdk.getBlueprint("civic-engagement-v1");
        const prover = blueprint.createProver();
        return await prover.generateProof(emlContent);
    }
    
    async verifyProof(proof: Proof): Promise<boolean> {
        const blueprint = await this.sdk.getBlueprint("civic-engagement-v1");
        return await blueprint.verifyProof(proof);
    }
}
```

### Email Processing Pipeline
```python
class EmailProcessor:
    def parse_eml(self, eml_content: str) -> EmailData:
        # Extract headers, sender, recipient, subject, timestamp
        
    def validate_dkim(self, email_data: EmailData) -> bool:
        # Verify DKIM signature authenticity
        
    def verify_representative(self, recipient: str) -> RepresentativeInfo:
        # Check against government contact database
```

### Campaign System
```typescript
type Campaign = 'chat_control' | 'sugar_tax' | 'sleep_compensation';

interface CampaignConfig {
    title: string;
    description: string;
    emailTemplate: string;
    targetRecipients: string[];
    rewardPoints: number;
    zkBlueprint: string;
}
```

## Data Models

### Email Data Structure
```python
class EmailData(BaseModel):
    sender: str
    recipient: str
    subject: str
    timestamp: datetime
    dkim_valid: bool
    message_id: str
    headers: Dict[str, str]
```

### ZK Proof Data
```typescript
interface CivicProof {
    proof: Proof;              // ZK-Email SDK proof object
    campaign: Campaign;        // Which campaign this proves
    timestamp: number;         // When proof was generated
    recipient_verified: boolean; // Is recipient a verified representative
    points_awarded: number;    // Civic engagement points earned
}
```

### Representative Database
```python
class Representative(BaseModel):
    email: str
    name: str
    title: str
    jurisdiction: str
    party: Optional[str]
    verified: bool
    contact_methods: List[str]
```

## ZK-Email Blueprint Design

### Custom Blueprint Requirements
```javascript
// Civic Engagement Blueprint
{
    "name": "civic-engagement-v1",
    "description": "Prove civic engagement without revealing email content",
    "inputs": [
        {
            "name": "sender_email",
            "type": "email",
            "public": false
        },
        {
            "name": "recipient_email", 
            "type": "email",
            "public": true
        },
        {
            "name": "subject_contains",
            "type": "string",
            "public": true
        },
        {
            "name": "timestamp_after",
            "type": "timestamp",
            "public": true
        }
    ],
    "outputs": [
        {
            "name": "valid_civic_engagement",
            "type": "boolean"
        }
    ]
}
```

## User Experience Flow

### 1. Campaign Selection
- User browses available civic campaigns
- Selects campaign of interest (e.g., "Stop Chat Control")
- System provides email template and representative contacts

### 2. Email Composition & Sending
- User copies provided template or writes custom email
- Sends email to representative through their email client
- Saves sent email as .eml file

### 3. Proof Generation
- User uploads .eml file to application
- System validates DKIM signature and recipient
- ZK-Email SDK generates privacy-preserving proof
- User sees progress indicators during proof generation

### 4. Verification & Rewards
- System verifies proof on-chain or off-chain
- Awards civic engagement points based on campaign
- Updates user's garden with new flowers
- Distributes NEAR token rewards via smart contract

## Error Handling

### Email Processing Errors
- **Invalid .eml Format**: Clear guidance on obtaining proper email files
- **Missing DKIM**: Warning with option to proceed for demo purposes
- **Unverified Recipient**: Reduced points with explanation
- **Parsing Failures**: Detailed error messages with troubleshooting steps

### ZK Proof Generation Errors
- **Blueprint Not Found**: Fallback to basic DKIM validation
- **Proof Generation Timeout**: Progress indicators with retry options
- **Invalid Email Content**: Specific validation error messages
- **Network Issues**: Offline mode with cached blueprints

### Blockchain Integration Errors
- **Wallet Not Connected**: Clear prompts to connect NEAR wallet
- **Transaction Failures**: Retry mechanisms with gas optimization
- **Smart Contract Errors**: User-friendly error translation
- **Network Congestion**: Queue system with status updates

## Security Considerations

### Privacy Protection
- Email content never stored on servers
- Only metadata hashes stored for verification
- ZK proofs reveal minimal necessary information
- Client-side proof generation prevents data leakage

### Authentication Security
- DKIM signature validation prevents email forgery
- Representative database prevents fake contacts
- Proof replay protection via timestamps
- Rate limiting on proof generation endpoints

### Smart Contract Security
- Proof verification on-chain prevents manipulation
- Multi-signature requirements for large rewards
- Reentrancy protection on reward distribution
- Overflow protection in point calculations

## Performance Optimization

### Client-Side Optimization
- Progressive loading of ZK-Email SDK
- Caching of frequently used blueprints
- Background proof generation with web workers
- Optimistic UI updates during verification

### Server-Side Optimization
- Representative database caching
- Batch processing of proof verifications
- CDN distribution of static blueprint data
- Connection pooling for blockchain interactions

## Testing Strategy

### Unit Tests
- Email parsing with various .eml formats
- DKIM validation with valid/invalid signatures
- ZK proof generation and verification
- Representative database lookups

### Integration Tests
- End-to-end civic engagement flow
- ZK-Email SDK integration
- NEAR blockchain interactions
- Error handling scenarios

### Security Tests
- Email forgery attempts
- Proof replay attacks
- Privacy leakage testing
- Smart contract vulnerability assessment